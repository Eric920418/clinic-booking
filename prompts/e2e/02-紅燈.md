# E2E Test Implementation - 紅燈生成器

## Role

將 E2E 測試樣板（純註解）轉換為可執行的 E2E 測試程式碼，依照註解中的 Handler Prompt 指引生成對應的程式碼，生成紅燈測試。

## Core Task

E2E 測試樣板（註解）→ 可執行 E2E 測試程式碼（紅燈）

## Input

1. 測試方法（包含註解樣板，來自 01-Feature-to-測試樣板.md）
2. Prisma Schema（Model 定義）
3. API Spec（api.yml）
4. Tech Stack（**TypeScript + Playwright + Prisma + Next.js**）
5. Handler Prompts（handlers/ 資料夾中的所有 Handler）

## Output

### 1. 測試程式碼

完整的 E2E 測試程式碼，包含：
- 必要的 import
- Playwright fixtures 和 beforeEach
- 完整的測試函式實作
- 所有測試邏輯完整實作

### 2. 基礎設施定義

**如果測試中需要用到的基礎設施尚不存在**，則按以下規則定義：

#### 生產環境基礎設施 (在 `src/` 中定義)

- **Prisma Schema**：在 `prisma/schema.prisma` 中定義（通常已存在）
- **API Routes**：在 `src/app/api/` 中定義（紅燈階段不實作邏輯）

#### 測試專用基礎設施 (在 `tests/e2e/` 中定義)

- **Helpers**：在 `tests/e2e/helpers/` 中定義 (db.ts, cleanup.ts, auth.ts)
- **Factories**：在 `tests/e2e/factories/` 中定義 (patient.ts, doctor.ts, appointment.ts)
- **測試文件組織**：
  - **LIFF 端測試** → `tests/e2e/liff/*.spec.ts`
  - **管理後台測試** → `tests/e2e/admin/*.spec.ts`
  - **API 測試** → `tests/e2e/api/*.spec.ts`
  - **基礎建設驗證** → `tests/e2e/setup/*.spec.ts`

**關鍵原則：僅定義介面和基礎設施，不實作後端業務邏輯**

- Prisma Schema 已定義完整
- Factory 函式定義完整
- 後端 API Route Handler 不實作業務邏輯
- E2E 測試會因為 API 回傳錯誤而失敗（紅燈）

---

## 重要規範

### API JSON 欄位命名規則

- ✅ **所有 API Request/Response 的 JSON 欄位使用 camelCase**（JavaScript/TypeScript 慣例）
- ✅ Prisma Schema 使用 camelCase 欄位名，資料庫使用 snake_case（透過 @map）
- ✅ Gherkin Feature File 使用自然語言，不受此限制

範例：
```typescript
// ✅ 正確
const response = await request.post('/api/liff/appointments', {
  data: {
    patientId: 'xxx',
    doctorId: 'yyy',
    appointmentDate: '2024-01-15'
  }
})
expect(body.data.appointmentId).toBeDefined()

// ❌ 錯誤
const response = await request.post('/api/liff/appointments', {
  data: {
    patient_id: 'xxx',  // 不要用 snake_case
    doctor_id: 'yyy'
  }
})
```

---

## 紅燈階段的核心原則

### E2E 測試的紅燈特色

與 Unit Test 的關鍵差異：

| 面向 | Unit Test 紅燈 | E2E Test 紅燈 |
|------|---------------|--------------|
| 測試失敗原因 | 函式拋出錯誤 | HTTP 4XX/5XX 或 UI 斷言失敗 |
| 需要定義的東西 | 型別、介面 | Prisma Schema, Factory, Helpers |
| 不需要定義的東西 | 業務邏輯 | 後端 API 業務邏輯 |
| 資料庫 | Mock | 真實 Supabase PostgreSQL |

### ✅ 要做的事

1. **完整實作測試程式碼**：測試邏輯必須完整且正確
2. **確認 Prisma Schema 已定義**：所有需要的 Model 必須存在
3. **定義 Factory 函式**：在 `tests/e2e/factories/` 中創建測試資料工廠
4. **設定測試基礎設施**：在 `tests/e2e/helpers/` 中定義必要的輔助函式
5. **連接測試資料庫**：使用 Supabase PostgreSQL

### ❌ 不要做的事

1. **不要實作後端 API 業務邏輯**：API Route Handler 只返回錯誤或空回應
2. **不要讓測試通過**：測試應該因為 API 未實作而失敗（紅燈）
3. **不要跳過基礎設施定義**：測試需要的 Factory、Helpers 必須定義

### 為什麼要這樣？

這是 TDD 的核心流程：
1. **紅燈**：寫測試 + 定義基礎設施（測試失敗）← 我們現在在這
2. **綠燈**：實作後端 API（測試通過）
3. **重構**：優化程式碼品質（測試持續通過）

---

## Execution Steps

### Step 1: 讀取測試樣板

識別測試函式中的每個註解區塊及其對應的 Handler Prompt

```typescript
test('成功建立預約', async ({ page, request }) => {
  // Given 準備一個病患 "王小明"
  // [事件風暴部位: Aggregate - Patient]
  // [生成參考 Prompt: Aggregate-Given-Handler.md]

  // When 病患 "王小明" 建立預約
  // [事件風暴部位: Command - create_appointment]
  // [生成參考 Prompt: Command-Handler.md]

  // Then 預約成功
  // [生成參考 Prompt: Success-Failure-Handler.md]

  // And 應該存在一個預約
  // [事件風暴部位: Aggregate - Appointment]
  // [生成參考 Prompt: Aggregate-Then-Handler.md]
})
```

### Step 2: 逐步生成程式碼

根據每個註解區塊的 Handler Prompt 生成對應的程式碼

#### 範例流程

**Given 區塊**：
- Handler: Aggregate-Given-Handler.md
- 生成: 使用 Factory 創建 entity → 儲存 ID 到 context

**When 區塊**：
- Handler: Command-Handler.md
- 生成: 從 context 取得 ID → 構建 request body → request.post() → 儲存 response 到 context

**Then 區塊**：
- Handler: Success-Failure-Handler.md
- 生成: 驗證 response.ok() 或 expect(locator).toBeVisible()

**And 區塊**：
- Handler: Aggregate-Then-Handler.md
- 生成: 使用 Prisma 查詢 entity → assert entity.field === expected

### Step 3: 生成測試基礎設施

包含必要的 factories、helpers

---

## Complete Example

### Input（測試樣板）

```typescript
test('成功建立預約', async ({ page, request }) => {
  // Given 準備一個病患 "王小明"
  // [事件風暴部位: Aggregate - Patient]
  // [生成參考 Prompt: Aggregate-Given-Handler.md]

  // And 準備一個醫師 "李醫師"
  // [事件風暴部位: Aggregate - Doctor]
  // [生成參考 Prompt: Aggregate-Given-Handler.md]

  // And 準備一個診療類型 "針灸"
  // [事件風暴部位: Aggregate - TreatmentType]
  // [生成參考 Prompt: Aggregate-Given-Handler.md]

  // And 準備一個時段 09:00-09:30
  // [事件風暴部位: Aggregate - TimeSlot]
  // [生成參考 Prompt: Aggregate-Given-Handler.md]

  // When 病患 "王小明" 建立預約
  // [事件風暴部位: Command - create_appointment]
  // [生成參考 Prompt: Command-Handler.md]

  // Then 預約成功
  // [生成參考 Prompt: Success-Failure-Handler.md]

  // And 應該存在一個預約
  // [事件風暴部位: Aggregate - Appointment]
  // [生成參考 Prompt: Aggregate-Then-Handler.md]
})
```

### Output 1（測試程式碼 - tests/e2e/liff/booking.spec.ts）

```typescript
// tests/e2e/liff/booking.spec.ts
import { test, expect } from '@playwright/test'
import { cleanupDatabase } from '../helpers/cleanup'
import { createPatient, createDoctor, createTreatmentType, createSchedule, createTimeSlot } from '../factories'
import { prisma } from '../helpers/db'

// 測試上下文，用於在步驟間傳遞資料
let context: Record<string, any> = {}

// Feature-level Background
test.beforeEach(async () => {
  // 清空資料庫，確保測試隔離
  await cleanupDatabase()
  context = {}
})

test.describe('預約需選擇診療類型和時段', () => {
  /**
   * Rule: 預約需選擇診療類型和時段
   */

  test('成功建立預約', async ({ request }) => {
    // Given 準備一個病患 "王小明"
    // [使用 Aggregate-Given-Handler.md]
    const patient = await createPatient({
      name: '王小明',
      phone: '0912345678',
      nationalId: 'A123456789',
      lineUserId: 'U1234567890',
    })
    context['patientId'] = patient.id

    // And 準備一個醫師 "李醫師"
    // [使用 Aggregate-Given-Handler.md]
    const doctor = await createDoctor({
      name: '李醫師',
      isActive: true,
    })
    context['doctorId'] = doctor.id

    // And 準備一個診療類型 "針灸"
    // [使用 Aggregate-Given-Handler.md]
    const treatmentType = await createTreatmentType({
      name: '針灸',
      durationMinutes: 5,
    })
    context['treatmentTypeId'] = treatmentType.id

    // And 準備一個時段 09:00-09:30
    // [使用 Aggregate-Given-Handler.md]
    const schedule = await createSchedule({
      doctorId: doctor.id,
      date: new Date('2024-01-15'),
    })
    const timeSlot = await createTimeSlot({
      scheduleId: schedule.id,
      startTime: new Date('1970-01-01T09:00:00'),
      endTime: new Date('1970-01-01T09:30:00'),
      remainingMinutes: 30,
    })
    context['timeSlotId'] = timeSlot.id

    // When 病患 "王小明" 建立預約
    // [使用 Command-Handler.md]
    const response = await request.post('/api/liff/appointments', {
      data: {
        patientId: context['patientId'],
        doctorId: context['doctorId'],
        treatmentTypeId: context['treatmentTypeId'],
        timeSlotId: context['timeSlotId'],
        appointmentDate: '2024-01-15',
      },
    })
    context['lastResponse'] = response

    // Then 預約成功
    // [使用 Success-Failure-Handler.md]
    expect(response.ok()).toBeTruthy()
    const body = await response.json()
    expect(body.success).toBe(true)

    // And 應該存在一個預約
    // [使用 Aggregate-Then-Handler.md]
    const appointment = await prisma.appointment.findFirst({
      where: {
        patientId: context['patientId'],
        doctorId: context['doctorId'],
      },
    })
    expect(appointment).not.toBeNull()
    expect(appointment?.status).toBe('booked')
  })

  test('時段已滿時無法預約', async ({ request }) => {
    // Given 準備測試資料
    const patient = await createPatient({ name: '王小明' })
    const doctor = await createDoctor({ name: '李醫師' })
    const treatmentType = await createTreatmentType({ name: '針灸', durationMinutes: 5 })
    const schedule = await createSchedule({ doctorId: doctor.id, date: new Date('2024-01-15') })

    // And 時段剩餘分鐘數為 0
    // [使用 Aggregate-Given-Handler.md]
    const timeSlot = await createTimeSlot({
      scheduleId: schedule.id,
      startTime: new Date('1970-01-01T09:00:00'),
      endTime: new Date('1970-01-01T09:30:00'),
      remainingMinutes: 0,  // 時段已滿
    })

    // When 病患 "王小明" 建立預約
    // [使用 Command-Handler.md]
    const response = await request.post('/api/liff/appointments', {
      data: {
        patientId: patient.id,
        doctorId: doctor.id,
        treatmentTypeId: treatmentType.id,
        timeSlotId: timeSlot.id,
        appointmentDate: '2024-01-15',
      },
    })

    // Then 預約失敗，顯示 "該時段已滿"
    // [使用 Success-Failure-Handler.md]
    expect(response.ok()).toBeFalsy()
    const body = await response.json()
    expect(body.success).toBe(false)
    expect(body.error).toContain('時段已滿')
  })
})

test.describe('同一病患當日只能預約一次', () => {
  /**
   * Rule: 同一病患當日只能預約一次
   */

  test('重複預約應被拒絕', async ({ request }) => {
    // Given 準備測試資料
    const patient = await createPatient({ name: '王小明' })
    const doctor = await createDoctor({ name: '李醫師' })
    const treatmentType = await createTreatmentType({ name: '針灸' })
    const schedule = await createSchedule({ doctorId: doctor.id, date: new Date('2024-01-15') })
    const timeSlot = await createTimeSlot({ scheduleId: schedule.id })

    // And 病患 "王小明" 已預約 2024-01-15 09:00 的針灸
    // [使用 Command-Handler.md]
    await prisma.appointment.create({
      data: {
        patientId: patient.id,
        doctorId: doctor.id,
        treatmentTypeId: treatmentType.id,
        timeSlotId: timeSlot.id,
        appointmentDate: new Date('2024-01-15'),
        status: 'booked',
      },
    })

    // When 病患 "王小明" 再次建立 2024-01-15 的預約
    // [使用 Command-Handler.md]
    const response = await request.post('/api/liff/appointments', {
      data: {
        patientId: patient.id,
        doctorId: doctor.id,
        treatmentTypeId: treatmentType.id,
        timeSlotId: timeSlot.id,
        appointmentDate: '2024-01-15',
      },
    })

    // Then 預約失敗，顯示 "當日已有預約"
    // [使用 Success-Failure-Handler.md]
    expect(response.ok()).toBeFalsy()
    const body = await response.json()
    expect(body.success).toBe(false)
    expect(body.code).toBe('E004')  // 當日已有預約
  })
})
```

### Output 2（Factory - tests/e2e/factories/patient.ts）

```typescript
// tests/e2e/factories/patient.ts
import { prisma } from '../helpers/db'

interface PatientData {
  name?: string
  phone?: string
  nationalId?: string
  lineUserId?: string
  birthDate?: Date
}

export async function createPatient(data: PatientData = {}) {
  const timestamp = Date.now()

  return prisma.patient.create({
    data: {
      name: data.name ?? '測試病患',
      phone: data.phone ?? `09${String(timestamp).slice(-8)}`,
      nationalId: data.nationalId ?? `A${String(timestamp).slice(-9)}`,
      lineUserId: data.lineUserId ?? `U${timestamp}`,
      birthDate: data.birthDate ?? new Date('1990-01-01'),
    },
  })
}
```

### Output 3（Factory - tests/e2e/factories/doctor.ts）

```typescript
// tests/e2e/factories/doctor.ts
import { prisma } from '../helpers/db'

interface DoctorData {
  name?: string
  isActive?: boolean
}

export async function createDoctor(data: DoctorData = {}) {
  return prisma.doctor.create({
    data: {
      name: data.name ?? '測試醫師',
      isActive: data.isActive ?? true,
    },
  })
}
```

### Output 4（Factory - tests/e2e/factories/index.ts）

```typescript
// tests/e2e/factories/index.ts
export { createPatient } from './patient'
export { createDoctor } from './doctor'
export { createTreatmentType } from './treatmentType'
export { createSchedule } from './schedule'
export { createTimeSlot } from './timeSlot'
export { createAppointment } from './appointment'
export { createAdmin } from './admin'
```

### Output 5（Helper - tests/e2e/helpers/db.ts）

```typescript
// tests/e2e/helpers/db.ts
import { PrismaClient } from '@prisma/client'

export const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.TEST_DATABASE_URL || process.env.DATABASE_URL,
    },
  },
})
```

### Output 6（Helper - tests/e2e/helpers/cleanup.ts）

```typescript
// tests/e2e/helpers/cleanup.ts
import { prisma } from './db'

export async function cleanupDatabase() {
  // 按照外鍵依賴順序刪除（子表先刪）
  await prisma.operationLog.deleteMany()
  await prisma.verificationCode.deleteMany()
  await prisma.appointment.deleteMany()
  await prisma.blacklist.deleteMany()
  await prisma.timeSlot.deleteMany()
  await prisma.schedule.deleteMany()
  await prisma.doctorTreatment.deleteMany()
  await prisma.treatmentType.deleteMany()
  await prisma.doctor.deleteMany()
  await prisma.patient.deleteMany()
  await prisma.adminUser.deleteMany()
}
```

### Output 7（Helper - tests/e2e/helpers/auth.ts）

```typescript
// tests/e2e/helpers/auth.ts
import jwt from 'jsonwebtoken'
import { Page } from '@playwright/test'

const JWT_SECRET = process.env.JWT_SECRET || 'test-secret-key'

export function generateAdminToken(adminId: string): string {
  return jwt.sign({ adminId }, JWT_SECRET, { expiresIn: '1h' })
}

export async function loginAsAdmin(page: Page, adminId: string) {
  const token = generateAdminToken(adminId)

  await page.context().addCookies([
    {
      name: 'admin_token',
      value: token,
      domain: 'localhost',
      path: '/',
    },
  ])
}

export function generateLiffContext(lineUserId: string) {
  return {
    lineUserId,
    // 其他 LIFF context 資訊
  }
}
```

### 預期結果：測試執行會失敗（紅燈）

```bash
$ pnpm test:e2e tests/e2e/liff/booking.spec.ts

FAILED tests/e2e/liff/booking.spec.ts:45:7 › 預約需選擇診療類型和時段 › 成功建立預約
Error: expect(received).toBeTruthy()
  Received: false

  Response status: 501 Not Implemented
```

**這就是紅燈**：
- ✅ 測試程式碼完整且正確
- ✅ Prisma Schema 定義完整（已存在）
- ✅ Factory 函式定義完整
- ✅ Helper 函式（cleanup, auth）設定完成
- ✅ 後端 API 未實作業務邏輯
- ✅ 測試執行會失敗

---

## Critical Rules

### R1: 測試程式碼必須完整

測試邏輯必須完整實作，不能只有註解。

```typescript
// ✅ 正確：完整的測試邏輯
test('成功建立預約', async ({ request }) => {
  const patient = await createPatient({ name: '王小明' })
  const doctor = await createDoctor({ name: '李醫師' })

  const response = await request.post('/api/liff/appointments', {
    data: {
      patientId: patient.id,
      doctorId: doctor.id,
      // ...
    },
  })

  expect(response.ok()).toBeTruthy()
  const body = await response.json()
  expect(body.success).toBe(true)
})

// ❌ 錯誤：測試邏輯不完整
test('成功建立預約', async ({ request }) => {
  // TODO: implement
})
```

### R2: 使用 Factory Pattern 建立測試資料

使用 Factory 函式建立測試資料，不直接使用 Prisma Client。

```typescript
// ✅ 正確：使用 Factory
const patient = await createPatient({ name: '王小明' })
const doctor = await createDoctor({ name: '李醫師' })

// ❌ 避免：直接使用 Prisma（除非在 Factory 內部）
const patient = await prisma.patient.create({
  data: {
    name: '王小明',
    phone: '0912345678',
    // 太多樣板代碼
  }
})
```

### R3: 每個測試前清空資料庫

使用 `test.beforeEach` 清空資料庫，確保測試隔離。

```typescript
// ✅ 正確：每個測試前清空
test.beforeEach(async () => {
  await cleanupDatabase()
  context = {}
})

// ❌ 錯誤：不清空資料庫
// 測試之間會互相影響
```

### R4: 測試檔案必須放在正確位置

```
✅ 正確：
- tests/e2e/liff/booking.spec.ts       (LIFF 預約測試)
- tests/e2e/liff/verify.spec.ts        (LIFF 驗證測試)
- tests/e2e/admin/login.spec.ts        (管理後台登入測試)
- tests/e2e/admin/dashboard.spec.ts    (Dashboard 測試)
- tests/e2e/api/appointments.spec.ts   (API 測試)
- tests/e2e/helpers/cleanup.ts         (輔助函式)
- tests/e2e/factories/patient.ts       (測試資料工廠)

❌ 錯誤：
- tests/e2e/test_booking.py            (錯誤的檔案格式)
- tests/booking.spec.ts                (錯誤的目錄)
```

### R5: 不實作後端 API 業務邏輯

紅燈階段不實作 API Route Handler 的業務邏輯。

```typescript
// ❌ 錯誤：在紅燈階段實作 API 邏輯
// src/app/api/liff/appointments/route.ts
export async function POST(request: NextRequest) {
  // 不應該在紅燈階段實作完整邏輯
  const body = await request.json()
  const appointment = await prisma.appointment.create({ data: body })
  return NextResponse.json({ success: true, data: appointment })
}

// ✅ 正確：紅燈階段可以只返回未實作
export async function POST(request: NextRequest) {
  return NextResponse.json(
    { success: false, error: 'Not implemented' },
    { status: 501 }
  )
}
```

### R6: 測試會失敗（紅燈）

紅燈階段的測試執行後應該失敗，這是預期的結果。

```bash
# ✅ 預期行為：測試失敗
$ pnpm test:e2e
FAILED - Error: expect(received).toBeTruthy()

# ❌ 不預期：測試通過（這應該在綠燈階段）
$ pnpm test:e2e
PASSED
```

### R7: Context 用於跨步驟傳遞資料

使用 context 物件在 Given/When/Then 之間傳遞資料。

```typescript
// ✅ 正確：使用 context 傳遞資料
let context: Record<string, any> = {}

test.beforeEach(async () => {
  context = {}
})

test('example', async ({ request }) => {
  // Given
  const patient = await createPatient()
  context['patientId'] = patient.id

  // When
  const response = await request.post('/api/liff/appointments', {
    data: { patientId: context['patientId'] }
  })
  context['lastResponse'] = response

  // Then
  expect(context['lastResponse'].ok()).toBeTruthy()
})
```

### R8: 參考 api.yml 構建 Request

Command 和 Query Handler 必須參考 api.yml 構建正確的 request。

```typescript
// ✅ 正確：根據 api.yml 構建 request
// api.yml 定義: POST /api/liff/appointments
// requestBody: { patientId, doctorId, treatmentTypeId, timeSlotId, appointmentDate }
const response = await request.post('/api/liff/appointments', {
  data: {
    patientId: patient.id,
    doctorId: doctor.id,
    treatmentTypeId: treatmentType.id,
    timeSlotId: timeSlot.id,
    appointmentDate: '2024-01-15',
  },
})

// ❌ 錯誤：自己猜測 API 格式
const response = await request.post('/appointments/create', {
  data: { patient: patient.id }  // 錯誤的欄位名稱
})
```

### R9: 錯誤訊息必須完整顯示在前端

測試驗證錯誤訊息時，確保錯誤有正確回傳。

```typescript
// ✅ 正確：驗證錯誤訊息
const response = await request.post('/api/liff/appointments', { data: { ... } })
expect(response.ok()).toBeFalsy()
const body = await response.json()
expect(body.success).toBe(false)
expect(body.error).toBeDefined()  // 確保有錯誤訊息
expect(body.code).toBe('E003')    // 確保有錯誤代碼

// ❌ 錯誤：只檢查 status code
expect(response.status()).toBe(400)  // 沒有驗證錯誤訊息
```

---

## 測試目錄結構

```
tests/
├── e2e/
│   ├── liff/                    # LIFF 端測試
│   │   ├── booking.spec.ts      # 預約流程
│   │   ├── verify.spec.ts       # 驗證流程
│   │   └── profile.spec.ts      # 個人資料
│   │
│   ├── admin/                   # 管理後台測試
│   │   ├── login.spec.ts        # 登入
│   │   ├── dashboard.spec.ts    # Dashboard
│   │   └── appointments.spec.ts # 預約管理
│   │
│   ├── api/                     # 純 API 測試
│   │   └── appointments.spec.ts
│   │
│   ├── factories/               # 測試資料工廠
│   │   ├── index.ts
│   │   ├── patient.ts
│   │   ├── doctor.ts
│   │   ├── treatmentType.ts
│   │   ├── schedule.ts
│   │   ├── timeSlot.ts
│   │   ├── appointment.ts
│   │   └── admin.ts
│   │
│   ├── helpers/                 # 輔助函式
│   │   ├── db.ts                # Prisma Client
│   │   ├── cleanup.ts           # 資料庫清理
│   │   └── auth.ts              # 認證輔助
│   │
│   └── setup/                   # 基礎建設驗證
│       └── health.spec.ts
│
└── playwright.config.ts         # Playwright 設定
```

---

## 與 Python 版本的比較

| 面向 | Python (pytest) | TypeScript (Playwright) |
|------|-----------------|-------------------------|
| 測試對象 | HTTP API | HTTP API + UI |
| 資料庫 | Testcontainers PostgreSQL | Supabase PostgreSQL |
| 失敗原因 | HTTP 404 | HTTP 4XX/5XX 或 UI 斷言 |
| 需要定義 | SQLAlchemy Model, Repository | Factory, Helpers |
| Models 位置 | `app/models/` | `prisma/schema.prisma` |
| 測試資料建立 | Repository Pattern | Factory Pattern |
| 測試文件位置 | `tests/e2e/test_*.py` | `tests/e2e/**/*.spec.ts` |
| Fixtures | `conftest.py` | `beforeEach` + helpers |
| Context | `context` dict fixture | `let context = {}` |

**關鍵共同點**：
- ✅ 測試程式碼必須完整
- ✅ 使用真實資料庫
- ✅ 不實作後端業務邏輯
- ✅ 測試會失敗（紅燈）
