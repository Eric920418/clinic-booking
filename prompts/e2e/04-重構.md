# TDD é‡æ§‹éšæ®µï¼šæ”¹å–„ç¨‹å¼ç¢¼å“è³ª

## ç›®æ¨™

åœ¨ä¿æŒæ¸¬è©¦é€šéï¼ˆç¶ ç‡ˆ ğŸŸ¢ï¼‰çš„å‰æä¸‹ï¼Œæ”¹å–„ç¨‹å¼ç¢¼å“è³ªã€‚

---

## æ ¸å¿ƒåŸå‰‡

### 1. æ¸¬è©¦ä¿è­·åŸå‰‡
æ¯æ¬¡é‡æ§‹å¾Œç«‹å³åŸ·è¡Œæ¸¬è©¦ï¼Œç¢ºä¿å…¨éƒ¨é€šéã€‚è‹¥å¤±æ•—å‰‡ç«‹å³å›æ»¾ã€‚

```bash
# æ¯æ¬¡é‡æ§‹å¾ŒåŸ·è¡Œ
pnpm test:e2e
```

### 2. å°æ­¥å‰é€²åŸå‰‡
ä¸€æ¬¡åªåšä¸€å€‹å°é‡æ§‹ï¼Œé¿å…ä¸€æ¬¡æ”¹å‹•éå¤šã€‚

### 3. ä¸å¼·è¡Œé‡æ§‹åŸå‰‡
åªåœ¨çœŸæ­£æœ‰æ”¹å–„ç©ºé–“æ™‚æ‰é‡æ§‹ã€‚ç¨‹å¼ç¢¼å·²æ¸…æ™°ç°¡æ½”æ™‚ä¿æŒåŸæ¨£ï¼Œéµå¾ª YAGNI åŸå‰‡ã€‚

### 4. è¨­è¨ˆåŸå‰‡éµå®ˆ
é‡æ§‹æ™‚å¿…é ˆéµå®ˆ SOLID è¨­è¨ˆåŸå‰‡ï¼Œé”åˆ°å¥½è®€ã€å¥½ç¶­è­·ã€å¥½æ“´å……ã€‚

### 5. æ¶æ§‹è¦ç¯„éµå®ˆ
**åš´æ ¼éµå®ˆ** `prompts/rules/ç¨‹å¼æ¶æ§‹è¦ç¯„.md`ï¼Œç¢ºä¿åˆ†å±¤æ¸…æ™°ã€è·è²¬æ˜ç¢ºã€‚

### 6. æ¸¬è©¦ Warnings æ¸…ç†
**ç›¡å¯èƒ½æ¸…é™¤æ‰€æœ‰æ¸¬è©¦ warnings**ï¼Œä¿æŒæ¸¬è©¦è¼¸å‡ºä¹¾æ·¨ã€‚warnings é€šå¸¸æŒ‡å‡ºæ½›åœ¨å•é¡Œæˆ–éæ™‚ç”¨æ³•ã€‚

### 7. TypeScript åš´æ ¼æ¨¡å¼
ç¢ºä¿æ‰€æœ‰ç¨‹å¼ç¢¼é€šé TypeScript åš´æ ¼æ¨¡å¼æª¢æŸ¥ï¼Œæ¶ˆé™¤ `any` é¡å‹ã€‚

---

## é‡æ§‹æ”¹å–„æ–¹å‘

### 1. SOLID è¨­è¨ˆåŸå‰‡

#### S - Single Responsibility Principleï¼ˆå–®ä¸€è·è²¬åŸå‰‡ï¼‰
æ¯å€‹æ¨¡çµ„/å‡½å¼åªè² è²¬ä¸€ä»¶äº‹ã€‚

**ç¯„ä¾‹ï¼š**
```typescript
// âŒ Service åšå¤ªå¤šäº‹
// lib/services/appointment.ts
export async function submitAppointment(patientId: string, data: AppointmentData) {
  // é©—è­‰æ¬Šé™
  const patient = await prisma.patient.findUnique({ where: { id: patientId } })
  if (patient?.isBlacklisted) throw new Error('æ¬Šé™ä¸è¶³')

  // é©—è­‰æ™‚æ®µ
  const timeSlot = await prisma.timeSlot.findUnique({ where: { id: data.timeSlotId } })
  if (!timeSlot || timeSlot.remainingMinutes < 10) throw new Error('æ™‚æ®µå·²æ»¿')

  // å»ºç«‹é ç´„
  const appointment = await prisma.appointment.create({ data: { ... } })

  // ç™¼é€ LINE é€šçŸ¥
  await sendLineMessage(patient.lineUserId, 'é ç´„æˆåŠŸ')

  // è¨˜éŒ„æ“ä½œæ—¥èªŒ
  await prisma.operationLog.create({ data: { action: 'create_appointment', ... } })

  return appointment
}

// âœ… è·è²¬åˆ†é›¢
// lib/services/appointment.ts
export async function submitAppointment(
  patientId: string,
  data: AppointmentData,
  deps: AppointmentServiceDeps = defaultDeps
) {
  // é©—è­‰æ¬Šé™äº¤çµ¦å°ˆé–€çš„å‡½å¼
  await deps.validatePatientPermission(patientId)

  // é©—è­‰æ™‚æ®µäº¤çµ¦å°ˆé–€çš„å‡½å¼
  await deps.validateTimeSlotAvailability(data.timeSlotId, data.treatmentTypeId)

  // å»ºç«‹é ç´„
  const appointment = await createAppointmentRecord(patientId, data)

  // é€šçŸ¥äº¤çµ¦å°ˆé–€çš„æœå‹™ï¼ˆå¯é¸æ“‡æ€§æ³¨å…¥ï¼‰
  await deps.notificationService?.notifyBookingSuccess(patientId, appointment)

  return appointment
}
```

#### D - Dependency Inversion Principleï¼ˆä¾è³´åè½‰åŸå‰‡ï¼‰
é«˜å±¤æ¨¡çµ„ä¸æ‡‰ä¾è³´ä½å±¤æ¨¡çµ„ï¼Œå…©è€…éƒ½æ‡‰ä¾è³´æŠ½è±¡ã€‚

**ç¯„ä¾‹ï¼š**
```typescript
// âœ… Service é€éåƒæ•¸æ³¨å…¥ä¾è³´
// lib/services/appointment.ts

// å®šç¾©ä¾è³´ä»‹é¢
interface AppointmentServiceDeps {
  prisma: PrismaClient
  notificationService?: NotificationService
}

// é è¨­ä¾è³´
const defaultDeps: AppointmentServiceDeps = {
  prisma: prismaClient,
  notificationService: lineNotificationService,
}

export async function createAppointment(
  data: CreateAppointmentInput,
  deps: AppointmentServiceDeps = defaultDeps
) {
  const { prisma } = deps

  // æ¥­å‹™é‚è¼¯ä½¿ç”¨æ³¨å…¥çš„ä¾è³´
  const timeSlot = await prisma.timeSlot.findUnique({
    where: { id: data.timeSlotId },
  })

  if (!timeSlot || timeSlot.remainingMinutes < 10) {
    throw new AppointmentError('TIME_SLOT_FULL', 'æ™‚æ®µå·²æ»¿')
  }

  // ...
}
```

### 2. æ¶æ§‹è¦ç¯„éµå®ˆ

#### åˆ†å±¤æ¶æ§‹æª¢æŸ¥

**Route Handler (app/api/)**ï¼š
- âœ… åªè™•ç† HTTP Request/Response
- âœ… å‘¼å« Service åŸ·è¡Œæ¥­å‹™é‚è¼¯
- âœ… ä½¿ç”¨ Zod é©—è­‰è«‹æ±‚è³‡æ–™
- âŒ ä¸åŒ…å«æ¥­å‹™é‚è¼¯
- âŒ ä¸ç›´æ¥æ“ä½œ Prisma

**Service (lib/services/)**ï¼š
- âœ… åŒ…å«æ¥­å‹™é‚è¼¯å’Œè¦å‰‡
- âœ… é€éåƒæ•¸æ³¨å…¥ä¾è³´ï¼ˆä¾¿æ–¼æ¸¬è©¦ï¼‰
- âœ… æ“ä½œ Prisma é€²è¡Œè³‡æ–™å­˜å–
- âŒ ä¸è™•ç† HTTP ç´°ç¯€ï¼ˆRequest/Responseï¼‰

**Validation (lib/validations/)**ï¼š
- âœ… ä½¿ç”¨ Zod å®šç¾©è³‡æ–™çµæ§‹
- âœ… åŒ¯å‡º Schema å’Œ TypeScript é¡å‹
- âŒ ä¸åŒ…å«æ¥­å‹™é‚è¼¯

#### ç¯„ä¾‹ï¼šç¬¦åˆæ¶æ§‹è¦ç¯„çš„é‡æ§‹

**é‡æ§‹å‰ï¼ˆé•ååˆ†å±¤æ¶æ§‹ï¼‰ï¼š**
```typescript
// app/api/liff/appointments/route.ts
export async function POST(request: Request) {
  const body = await request.json()

  // âŒ Route Handler åŒ…å«æ¥­å‹™é‚è¼¯
  const patient = await prisma.patient.findUnique({
    where: { id: body.patientId },
  })
  if (!patient) {
    return NextResponse.json({ error: 'ç—…æ‚£ä¸å­˜åœ¨' }, { status: 404 })
  }
  if (patient.isBlacklisted) {
    return NextResponse.json({ error: 'å·²è¢«åˆ—å…¥é»‘åå–®' }, { status: 403 })
  }

  // âŒ Route Handler ç›´æ¥æ“ä½œ Prisma
  const timeSlot = await prisma.timeSlot.findUnique({
    where: { id: body.timeSlotId },
  })
  if (!timeSlot || timeSlot.remainingMinutes < 10) {
    return NextResponse.json({ error: 'æ™‚æ®µå·²æ»¿' }, { status: 400 })
  }

  const appointment = await prisma.appointment.create({
    data: { ... },
  })

  return NextResponse.json({ data: appointment }, { status: 201 })
}
```

**é‡æ§‹å¾Œï¼ˆç¬¦åˆåˆ†å±¤æ¶æ§‹ï¼‰ï¼š**
```typescript
// app/api/liff/appointments/route.ts
import { NextResponse } from 'next/server'
import { createAppointmentSchema } from '@/lib/validations/appointment'
import { createAppointment } from '@/lib/services/appointment'
import { AppointmentError } from '@/lib/errors'

export async function POST(request: Request) {
  // âœ… Route Handler åªè™•ç† HTTP
  const body = await request.json()

  // âœ… ä½¿ç”¨ Zod é©—è­‰
  const result = createAppointmentSchema.safeParse(body)
  if (!result.success) {
    return NextResponse.json(
      { error: 'é©—è­‰å¤±æ•—', details: result.error.flatten() },
      { status: 400 }
    )
  }

  try {
    // âœ… å‘¼å« Service åŸ·è¡Œæ¥­å‹™é‚è¼¯
    const appointment = await createAppointment(result.data)
    return NextResponse.json({ data: appointment }, { status: 201 })
  } catch (error) {
    if (error instanceof AppointmentError) {
      return NextResponse.json(
        { error: error.message, code: error.code },
        { status: error.statusCode }
      )
    }
    throw error
  }
}

// lib/services/appointment.ts
import { prisma } from '@/lib/prisma'
import type { CreateAppointmentInput } from '@/lib/validations/appointment'
import { AppointmentError } from '@/lib/errors'

export async function createAppointment(data: CreateAppointmentInput) {
  // âœ… Service åŒ…å«æ¥­å‹™é‚è¼¯
  const patient = await prisma.patient.findUnique({
    where: { id: data.patientId },
  })

  if (!patient) {
    throw new AppointmentError('PATIENT_NOT_FOUND', 'ç—…æ‚£ä¸å­˜åœ¨', 404)
  }

  if (patient.isBlacklisted) {
    throw new AppointmentError('PATIENT_BLACKLISTED', 'å·²è¢«åˆ—å…¥é»‘åå–®', 403)
  }

  // âœ… é€é Prisma æ“ä½œè³‡æ–™
  const timeSlot = await prisma.timeSlot.findUnique({
    where: { id: data.timeSlotId },
  })

  if (!timeSlot || timeSlot.remainingMinutes < data.durationMinutes) {
    throw new AppointmentError('TIME_SLOT_FULL', 'æ™‚æ®µå·²æ»¿', 400)
  }

  // ä½¿ç”¨ Transaction ç¢ºä¿è³‡æ–™ä¸€è‡´æ€§
  return prisma.$transaction(async (tx) => {
    const appointment = await tx.appointment.create({
      data: {
        patientId: data.patientId,
        doctorId: data.doctorId,
        timeSlotId: data.timeSlotId,
        treatmentTypeId: data.treatmentTypeId,
        appointmentDate: new Date(),
        status: 'booked',
      },
    })

    await tx.timeSlot.update({
      where: { id: data.timeSlotId },
      data: { remainingMinutes: { decrement: data.durationMinutes } },
    })

    return appointment
  })
}
```

### 3. ç¨‹å¼ç¢¼å“è³ªæ”¹å–„

#### Early Return åŸå‰‡
æ¸›å°‘å·¢ç‹€ï¼Œæå‡å¯è®€æ€§ã€‚

```typescript
// âŒ æ·±å±¤å·¢ç‹€
async function processAppointment(data: AppointmentData) {
  const patient = await prisma.patient.findUnique({ where: { id: data.patientId } })
  if (patient) {
    if (!patient.isBlacklisted) {
      const timeSlot = await prisma.timeSlot.findUnique({ where: { id: data.timeSlotId } })
      if (timeSlot && timeSlot.remainingMinutes >= 10) {
        return createAppointment(data)
      } else {
        throw new Error('æ™‚æ®µå·²æ»¿')
      }
    } else {
      throw new Error('å·²è¢«åˆ—å…¥é»‘åå–®')
    }
  } else {
    throw new Error('ç—…æ‚£ä¸å­˜åœ¨')
  }
}

// âœ… Early return
async function processAppointment(data: AppointmentData) {
  const patient = await prisma.patient.findUnique({ where: { id: data.patientId } })
  if (!patient) {
    throw new AppointmentError('PATIENT_NOT_FOUND', 'ç—…æ‚£ä¸å­˜åœ¨')
  }

  if (patient.isBlacklisted) {
    throw new AppointmentError('PATIENT_BLACKLISTED', 'å·²è¢«åˆ—å…¥é»‘åå–®')
  }

  const timeSlot = await prisma.timeSlot.findUnique({ where: { id: data.timeSlotId } })
  if (!timeSlot || timeSlot.remainingMinutes < 10) {
    throw new AppointmentError('TIME_SLOT_FULL', 'æ™‚æ®µå·²æ»¿')
  }

  return createAppointment(data)
}
```

#### å¸¸æ•¸æå–
é‡è¤‡ä½¿ç”¨çš„å€¼æå–ç‚ºå¸¸æ•¸ï¼Œæå‡å¯ç¶­è­·æ€§ã€‚

```typescript
// âŒ é­”è¡“æ•¸å­—æ•£è½å„è™•
async function validateTimeSlot(timeSlotId: string, treatmentTypeId: string) {
  const timeSlot = await prisma.timeSlot.findUnique({ where: { id: timeSlotId } })
  if (!timeSlot || timeSlot.remainingMinutes < 5) {  // 5 æ˜¯ä»€éº¼ï¼Ÿ
    throw new Error('æ™‚æ®µå·²æ»¿')
  }
  // ...
}

// âœ… å¸¸æ•¸æå–
// lib/constants/appointment.ts
export const APPOINTMENT_CONSTANTS = {
  MIN_REMAINING_MINUTES: 5,
  MAX_BOOKING_DAYS_AHEAD: 14,
  MAX_NO_SHOW_COUNT: 3,
} as const

// lib/services/appointment.ts
import { APPOINTMENT_CONSTANTS } from '@/lib/constants/appointment'

async function validateTimeSlot(timeSlotId: string) {
  const timeSlot = await prisma.timeSlot.findUnique({ where: { id: timeSlotId } })
  if (!timeSlot || timeSlot.remainingMinutes < APPOINTMENT_CONSTANTS.MIN_REMAINING_MINUTES) {
    throw new AppointmentError('TIME_SLOT_FULL', 'æ™‚æ®µå·²æ»¿')
  }
}
```

#### æ˜ç¢ºçš„è¿”å›é¡å‹
ä½¿ç”¨ Zod infer æˆ–æ˜ç¢ºçš„ TypeScript é¡å‹ã€‚

```typescript
// âŒ æ¨¡ç³Šçš„è¿”å›é¡å‹
async function getAppointmentDetails(id: string) {
  return prisma.appointment.findUnique({
    where: { id },
    include: { patient: true, doctor: true },
  })
}

// âœ… æ˜ç¢ºçš„è¿”å›é¡å‹
import type { Appointment, Patient, Doctor } from '@prisma/client'

type AppointmentWithRelations = Appointment & {
  patient: Patient
  doctor: Doctor
}

async function getAppointmentDetails(id: string): Promise<AppointmentWithRelations | null> {
  return prisma.appointment.findUnique({
    where: { id },
    include: { patient: true, doctor: true },
  })
}

// âœ… æˆ–ä½¿ç”¨ Zod å®šç¾© API å›æ‡‰æ ¼å¼
import { z } from 'zod'

export const appointmentResponseSchema = z.object({
  id: z.string().uuid(),
  status: z.enum(['booked', 'checked_in', 'completed', 'no_show', 'cancelled']),
  appointmentDate: z.string().datetime(),
  patient: z.object({
    id: z.string().uuid(),
    name: z.string(),
  }),
  doctor: z.object({
    id: z.string().uuid(),
    name: z.string(),
  }),
})

export type AppointmentResponse = z.infer<typeof appointmentResponseSchema>
```

#### å‘½åæ¸…æ™°åŒ–
```typescript
// âŒ ä¸æ¸…æ¥šçš„å‘½å
async function process(data: unknown) {
  const result = await prisma.appointment.findMany({ where: { status: 'booked' } })
  return result
}

// âœ… æ¸…æ™°çš„å‘½å
async function findPendingAppointmentsByPatient(patientId: string) {
  const pendingAppointments = await prisma.appointment.findMany({
    where: {
      patientId,
      status: 'booked',
      appointmentDate: { gte: new Date() },
    },
  })
  return pendingAppointments
}
```

#### æ¶ˆé™¤é‡è¤‡é‚è¼¯
```typescript
// âŒ é‡è¤‡çš„é©—è­‰é‚è¼¯
async function createAppointment(data: CreateAppointmentInput) {
  const patient = await prisma.patient.findUnique({ where: { id: data.patientId } })
  if (!patient) throw new AppointmentError('PATIENT_NOT_FOUND', 'ç—…æ‚£ä¸å­˜åœ¨')
  if (patient.isBlacklisted) throw new AppointmentError('BLACKLISTED', 'å·²è¢«åˆ—å…¥é»‘åå–®')
  // ...
}

async function updateAppointment(id: string, data: UpdateAppointmentInput) {
  const patient = await prisma.patient.findUnique({ where: { id: data.patientId } })
  if (!patient) throw new AppointmentError('PATIENT_NOT_FOUND', 'ç—…æ‚£ä¸å­˜åœ¨')
  if (patient.isBlacklisted) throw new AppointmentError('BLACKLISTED', 'å·²è¢«åˆ—å…¥é»‘åå–®')
  // ...
}

// âœ… æå–å…±ç”¨å‡½å¼
async function validatePatientCanBook(patientId: string): Promise<Patient> {
  const patient = await prisma.patient.findUnique({ where: { id: patientId } })

  if (!patient) {
    throw new AppointmentError('PATIENT_NOT_FOUND', 'ç—…æ‚£ä¸å­˜åœ¨', 404)
  }

  if (patient.isBlacklisted) {
    throw new AppointmentError('PATIENT_BLACKLISTED', 'å·²è¢«åˆ—å…¥é»‘åå–®', 403)
  }

  return patient
}

async function createAppointment(data: CreateAppointmentInput) {
  await validatePatientCanBook(data.patientId)
  // ...
}

async function updateAppointment(id: string, data: UpdateAppointmentInput) {
  await validatePatientCanBook(data.patientId)
  // ...
}
```

---

### 4. æ¸¬è©¦ Warnings æ¸…ç†

æ¸…é™¤æ¸¬è©¦åŸ·è¡Œæ™‚ç”¢ç”Ÿçš„æ‰€æœ‰ warningsï¼Œä¿æŒæ¸¬è©¦è¼¸å‡ºä¹¾æ·¨ã€‚

```bash
# åŸ·è¡Œæ¸¬è©¦æª¢æŸ¥ warnings
pnpm test:e2e 2>&1 | grep -i warning
```

å¸¸è¦‹ warnings èˆ‡ä¿®å¾©æ–¹å¼ï¼š

| Warning | åŸå›  | ä¿®å¾©æ–¹å¼ |
|---------|------|---------|
| `act() warning` | æœªåŒ…è£ç‹€æ…‹æ›´æ–° | ä½¿ç”¨ `await page.waitForSelector()` |
| `Unhandled promise rejection` | æœªè™•ç†çš„ Promise éŒ¯èª¤ | åŠ å…¥ try-catch æˆ– `.catch()` |
| `Deprecated API` | ä½¿ç”¨éæ™‚çš„ API | æ›´æ–°ç‚ºæ–° API |

---

## E2E é‡æ§‹é …ç›®

### 1. Meta è¨»è¨˜æ¸…ç†

#### åˆªé™¤çš„å…§å®¹
- `// [äº‹ä»¶é¢¨æš´éƒ¨ä½: ...]`
- `// [ç”Ÿæˆåƒè€ƒ Prompt: ...]`

#### ä¿ç•™çš„å…§å®¹
- Given/When/Then/And æ¥­å‹™é‚è¼¯æè¿°
- å¿…è¦çš„æŠ€è¡“è¨»è§£

#### ç¯„ä¾‹

**é‡æ§‹å‰ï¼š**
```typescript
test('æ‡‰æˆåŠŸå»ºç«‹é ç´„', async ({ request }) => {
  // Given ç—…æ‚£å·²å®Œæˆèº«åˆ†é©—è­‰
  // [äº‹ä»¶é¢¨æš´éƒ¨ä½: Aggregate - Patient]
  // [ç”Ÿæˆåƒè€ƒ Prompt: Aggregate-Given-Handler.md]

  const patient = await createPatient()

  // When ç—…æ‚£é¸æ“‡æ™‚æ®µä¸¦ç¢ºèªé ç´„
  // [äº‹ä»¶é¢¨æš´éƒ¨ä½: Command - create_appointment]
  // [ç”Ÿæˆåƒè€ƒ Prompt: Command-Handler.md]

  const response = await request.post('/api/liff/appointments', {
    data: { patientId: patient.id, timeSlotId: timeSlot.id },
  })

  // Then é ç´„å»ºç«‹æˆåŠŸ
  // [ç”Ÿæˆåƒè€ƒ Prompt: Success-Failure-Handler.md]
  expect(response.status()).toBe(201)
})
```

**é‡æ§‹å¾Œï¼š**
```typescript
test('æ‡‰æˆåŠŸå»ºç«‹é ç´„', async ({ request }) => {
  // Given ç—…æ‚£å·²å®Œæˆèº«åˆ†é©—è­‰
  const patient = await createPatient()

  // When ç—…æ‚£é¸æ“‡æ™‚æ®µä¸¦ç¢ºèªé ç´„
  const response = await request.post('/api/liff/appointments', {
    data: { patientId: patient.id, timeSlotId: timeSlot.id },
  })

  // Then é ç´„å»ºç«‹æˆåŠŸ
  expect(response.status()).toBe(201)
})
```

---

### 2. Test Helpers æ¶æ§‹

#### åŸå‰‡
E2E æ¸¬è©¦ä¾è³´ `tests/e2e/helpers/` å’Œ `tests/e2e/factories/` æä¾›çš„å·¥å…·å‡½å¼ã€‚

#### æ¨™æº–ç›®éŒ„çµæ§‹
```
tests/e2e/
â”œâ”€â”€ helpers/
â”‚   â”œâ”€â”€ prisma.ts       # Prisma å®¢æˆ¶ç«¯èˆ‡æ¸…ç†é‚è¼¯
â”‚   â”œâ”€â”€ auth.ts         # èªè­‰ç›¸é—œ helper
â”‚   â””â”€â”€ api.ts          # API è«‹æ±‚ helper
â”œâ”€â”€ factories/
â”‚   â”œâ”€â”€ patient.ts      # Patient å·¥å» 
â”‚   â”œâ”€â”€ doctor.ts       # Doctor å·¥å» 
â”‚   â”œâ”€â”€ timeSlot.ts     # TimeSlot å·¥å» 
â”‚   â””â”€â”€ appointment.ts  # Appointment å·¥å» 
â””â”€â”€ fixtures/
    â””â”€â”€ global-setup.ts # å…¨åŸŸè¨­å®š
```

#### Feature Background ç¯„ä¾‹
```typescript
// tests/e2e/booking.spec.ts
import { test, expect } from '@playwright/test'
import { createPatient } from './factories/patient'
import { createDoctor } from './factories/doctor'
import { createTimeSlot } from './factories/timeSlot'
import { cleanupDatabase } from './helpers/prisma'

test.describe('é ç´„åŠŸèƒ½', () => {
  // Background: æ¯å€‹æ¸¬è©¦å‰çš„å…±ç”¨è¨­å®š
  test.beforeEach(async () => {
    await cleanupDatabase()
  })

  test('æ‡‰æˆåŠŸå»ºç«‹é ç´„', async ({ request }) => {
    // Given ç³»çµ±ä¸­æœ‰ç—…æ‚£å’Œå¯ç”¨æ™‚æ®µ
    const patient = await createPatient({ name: 'ç‹å°æ˜' })
    const doctor = await createDoctor({ name: 'æé†«å¸«' })
    const timeSlot = await createTimeSlot({
      doctorId: doctor.id,
      remainingMinutes: 30,
    })

    // When ç—…æ‚£å»ºç«‹é ç´„
    const response = await request.post('/api/liff/appointments', {
      data: {
        patientId: patient.id,
        doctorId: doctor.id,
        timeSlotId: timeSlot.id,
        treatmentTypeId: 'first-visit',
      },
    })

    // Then é ç´„æˆåŠŸ
    expect(response.status()).toBe(201)
  })
})
```

---

## é‡æ§‹æª¢æŸ¥æ¸…å–®

åŸ·è¡Œ E2E æ¸¬è©¦é‡æ§‹æ™‚ç¢ºèªï¼š

### æ¸¬è©¦ç¨‹å¼ç¢¼
- [ ] æ‰€æœ‰ Meta è¨»è¨˜å·²åˆªé™¤
- [ ] Given/When/Then æ¥­å‹™é‚è¼¯è¨»è§£å·²ä¿ç•™
- [ ] ä½¿ç”¨ `tests/e2e/helpers/` å’Œ `tests/e2e/factories/` æä¾›çš„å·¥å…·
- [ ] æ¯å€‹æ¸¬è©¦ç¨ç«‹ï¼ˆä½¿ç”¨ `beforeEach` æ¸…ç†è³‡æ–™ï¼‰

### å¯¦ä½œç¨‹å¼ç¢¼
- [ ] ç¬¦åˆ SOLID è¨­è¨ˆåŸå‰‡
- [ ] Service é€éåƒæ•¸æ³¨å…¥ä¾è³´ï¼ˆä¾¿æ–¼æ¸¬è©¦ï¼‰
- [ ] Route Handler åªè™•ç† HTTPï¼Œä¸åŒ…å«æ¥­å‹™é‚è¼¯
- [ ] ä½¿ç”¨ Zod é©—è­‰è«‹æ±‚è³‡æ–™
- [ ] éµå®ˆ `prompts/rules/ç¨‹å¼æ¶æ§‹è¦ç¯„.md`
- [ ] æª”æ¡ˆæ”¾ç½®æ–¼æ­£ç¢ºç›®éŒ„ï¼ˆapp/api/, lib/services/, lib/validations/ï¼‰

### TypeScript å“è³ª
- [ ] ç„¡ `any` é¡å‹ï¼ˆé™¤éå¿…è¦ä¸”æœ‰è¨»è§£èªªæ˜ï¼‰
- [ ] æ‰€æœ‰å‡½å¼æœ‰æ˜ç¢ºçš„è¿”å›é¡å‹
- [ ] ä½¿ç”¨ Zod infer æˆ–æ˜ç¢ºçš„ TypeScript é¡å‹

### æ¸¬è©¦é©—è­‰
- [ ] æ‰€æœ‰æ¸¬è©¦é€šé ğŸŸ¢
- [ ] æ‰€æœ‰æ¸¬è©¦ warnings å·²æ¸…é™¤
- [ ] TypeScript ç·¨è­¯ç„¡éŒ¯èª¤

```bash
# é©—è­‰æŒ‡ä»¤
pnpm test:e2e          # æ‰€æœ‰æ¸¬è©¦é€šé
pnpm typecheck         # TypeScript ç„¡éŒ¯èª¤
pnpm lint              # ESLint ç„¡éŒ¯èª¤
```

---

## é‡æ§‹åŸå‰‡ç¸½çµ

âœ… **æ‡‰è©²åšï¼š**
- æ¸…ç† Meta è¨»è¨˜
- ä¿ç•™æ¥­å‹™é‚è¼¯è¨»è§£
- ä¾è³´ helpers/ å’Œ factories/ å·¥å…·å‡½å¼
- éµå®ˆ SOLID è¨­è¨ˆåŸå‰‡
- åš´æ ¼éµå®ˆæ¶æ§‹è¦ç¯„ï¼ˆåˆ†å±¤æ¸…æ™°ã€ä¾è³´æ³¨å…¥ï¼‰
- æ¸…é™¤æ‰€æœ‰æ¸¬è©¦ warnings
- ç¢ºä¿ TypeScript é¡å‹å®‰å…¨

âŒ **ä¸æ‡‰è©²åšï¼š**
- éåº¦æå–ï¼ˆhelpers/ å’Œ factories/ å·²è¶³å¤ ï¼‰
- æ”¹è®Šæ¸¬è©¦çµæ§‹
- å¼·è¡Œç°¡åŒ–å¯è®€æ€§
- é•åæ¶æ§‹è¦ç¯„ï¼ˆå¦‚ Route Handler åŒ…å«æ¥­å‹™é‚è¼¯ï¼‰
- å¿½ç•¥æ¸¬è©¦ warnings
- ä½¿ç”¨ `any` é¡å‹è¿´é¿é¡å‹æª¢æŸ¥
